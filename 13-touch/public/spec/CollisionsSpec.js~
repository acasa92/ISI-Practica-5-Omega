/*

  Requisitos:

  El objetivo de este prototipo es que se detecten colisiones entre
  varios tipos de sprites:
  
  - Los misiles tienen ahora una nueva propiedad: el daño (damage) que
    producen cuando colisionan con una nave enemiga. Cuando un misil
    colisione con una nave enemiga le infligirá un daño de cierta
    cuantía a la nave enemiga con la que impacta, y desaparecerá.

  - Las naves enemigas tienen ahora una nueva propiedad: su salud
    (health).  El daño ocasionado a una nave enemiga por un misil hará
    que disminuya la salud de la nave enemiga, y cuando llegue a cero,
    la nave enemiga desaparecerá.

  - cuando una nave enemiga colisione con la nave del jugador, deberá
    desaparecer tanto la nave enemiga como la nave del jugador.



  Especificación:

  En el prototipo 07-gameboard se añadió el constructor GameBoard. El
  método overlap() de los objetos creados con GameBoard() ofrece
  funcionalidad para comprobar si los rectángulos que circunscriben a
  los sprites que se le pasan como parámetros tienen intersección no
  nula. El método collide() de GameBoard utiliza overlap() para
  detectar si el objeto que se le pasa como primer parámetro ha
  colisionado con algún objeto del tipo que se le pasa como segundo
  parámetro.

  En este prototipo se utilizará el método collide() para detectar los
  siguientes tipos de colisiones:

    a) detectar si un misil disparado por la nave del jugador
       colisiona con una nave enemiga

    b) detectar si una nave enemiga colisiona con la nave del jugador


  En el método step() de los objetos creados con PlayerMissile() y
  Enemy(), tras "moverse" a su nueva posición calculada, se comprobará
  si han colisionado con algún objeto del tipo correspondiente. 

  No interesa comprobar si se colisiona con cualquier otro objeto,
  sino sólo con los de ciertos tipos. El misil tiene que comprobar si
  colisiona con enemigos. El enemigo tiene que comprobar si colisiona
  con la nave del jugador. Para ello cada sprite tiene un tipo y
  cuando se comprueba si un sprite ha colisionado con otros, se pasa
  como segundo argumento a collide() el tipo de sprites con los que se
  quiere ver si ha colisionado el objeto que se pasa como primer
  argumento.

  Cuando un objeto detecta que ha colisionado con otro llama al método
  hit() del objeto con el que ha colisionado. El misil cuando llama a
  hit() de una nave enemiga pasa como parámetro el daño que provoca
  para que la nave enemiga pueda calcular la reducción de salud que
  conlleva la colisión.


  Efectos de las colisiones:

  Cuando una nave enemiga recibe la llamada .hit() realizada por un
  misil que ha detectado la colisión, recalcula su salud reduciéndola
  en tantas unidades como el daño del misil indique, y si su salud
  llega a 0 desaparece del tablero de juegos, produciéndose en su
  lugar la animación de una explosión.

  Cuando la nave del jugador recibe la llamada .hit() realizada por
  una nave enemiga que ha detectado la colisión, desaparece.

  El misil, tras informar llamando al métod hit() de la nave enemiga
  con la que ha detectado colisión, desaparece.

  La nave enemiga, tras informar llamando a hit() de la nave del
  jugador, desaparece.

*/

describe("CollisionsSpec", function() {

	var canvas, ctx;
	var enemies = {
   		 basic: { x: 100, y: -50, sprite: 'enemy_purple', B: 100, C: 4, E: 100, health: 20 }
	};
	beforeEach(function(){
		loadFixtures('index.html');

		canvas = $('#game')[0];
		expect(canvas).toExist();

		ctx = canvas.getContext('2d');
		expect(ctx).toBeDefined();

	});


	it("Bola de fuego contra nave", function() {
		SpriteSheet = { 
			map : {enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frames: 1 },
				fireball: { sx: 0, sy: 64, w: 64, h: 64, frames: 1 },
				explosion: { sx: 0, sy: 64, w: 64, h: 64, frames: 12 }}
		};
		var miBola = new PlayerFireball(1,2,1);
		miBola.x=1;
		miBola.y=2;
		var pm = new Enemy(enemies.basic);
		pm.x=1;
		pm.y=2;
		var board = new GameBoard();

		board.add(miBola);
		board.add(pm);
		
		board.step(0.0000000001);
		expect(board.objects.length).toBe(2);
		expect(board.objects[0]).toBe(miBola);
		expect(board.objects[1].sprite).toBe('explosion');

	});
	
	it("Nave contra PlayerShip", function() {
		SpriteSheet = { 
			map : {enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frames: 1 },
				ship: { sx: 0, sy: 0, w: 37, h: 42, frames: 1 },
				explosion: { sx: 0, sy: 64, w: 64, h: 64, frames: 12 }}
		};
		
		Game = {
			setBoard:function(){},
			keys: {}
		};

		var miShip = new PlayerShip();
		miShip.x=1;
		miShip.y=2;
		var pm = new Enemy(enemies.basic);
		pm.x=1;
		pm.y=2;
		var board = new GameBoard();
		
		board.add(miShip);
		board.add(pm);

		board.step(0.0000000001);
		expect(board.objects.length).toBe(1);
	        expect(board.objects[0].sprite).toBe('explosion');
	});
	
	it("un misil destruye una nave", function() {
		SpriteSheet = {
				map : {
					missile: {h:10, w:2},
					enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frames: 1 },
					explosion: { sx: 0, sy: 64, w: 64, h: 64, frames: 12 },
				}
		};

		var gb = new GameBoard();
		var misil = new PlayerMissile(5,5);
		misil.x = 5;
		misil.y = 5;
		misil.damage = 10;
		var enem = new Enemy(enemies.basic);
		enem.x = 5;
		enem.y = 5;
		enem.health = 10;


		gb.add(misil);
		gb.add(enem);

		gb.step(0.0001);
		expect(gb.objects.length).toBe(1);
		expect(gb.objects[0].sprite).toBe('explosion');

	});
	
	it("un misil no destruye una nave", function() {
		SpriteSheet = {
				map : {
					missile: {h:10, w:2},
					enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frames: 1 },
					explosion: { sx: 0, sy: 64, w: 64, h: 64, frames: 12 },
				}
		};

		var gb = new GameBoard();
		var misil = new PlayerMissile(5,5);
		misil.x = 5;
		misil.y = 5;
		misil.damage = 10;
		var enem = new Enemy(enemies.basic);
		enem.x = 5;
		enem.y = 5;
		enem.health = 20;


		gb.add(misil);
		gb.add(enem);

		gb.step(0.0001);
		expect(gb.objects.length).toBe(1);
		expect(gb.objects[0]).toBe(enem);
		expect(enem.health).toBe(10);

	});


});
